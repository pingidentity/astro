<<<<<<< HEAD
# Upgrading the UI Library from 3.x to 4.0.0
If you have a project that currently uses a 3.x version of the UI Library, try these steps to upgrade to v4:
1. Upgrade to the latest 3.x version. While v4 is still in beta, you can do this by running `npm install ui-library@latest`
2. Run your project with the console open. You will probably see a lot of "Cannonball" warnings about potential behavior changes. These changes are summarized below.
3. Either address the warnings one-by-one or, if you don't think the changes will have a big impact, move on to testing out v4.
4. You can test the v4 behaviors by wrapping your whole application in `<FlagsProvider flags={["v4"]}></FlagsProvider>`.
5. Review your application for broken behaviors.
6. Install v4. While it is still in beta, run `npm install ui-library@beta`.
=======
# Getting Ready for Cannonball: the UI Library Version 4.0.0

We are currently planning to release version 4.0.0 in October 2019, followed by a short period of joint v3 and v4 development.
While we will continue to support v3 of the Library, beginning in 2020, all further component development will be done in v4.

You can try out a beta version of v4 in your projects with this command: `npm install ui-library@beta`

Our goal is to make the upgrade close to painless. To that end, we developed the new v4 behaviors in v3 and put them behind feature flags. This allows you to try out v4 right away and make any changes you need to make over the next few months. If you are already using the latest version of the library, you should be seeing several console warnings calling out components you should address. These fall into a few main categories.
>>>>>>> origin/master

## Progressive Statefulness
In v4, we did away with the `stateless` prop and the hard distinction between stateful and stateless versions of our components. Our new model allows you to choose which props you’d like to control and which you’d like the component to control. These components take control of any potentially stateful props on mount if no value is provided.

Since you are currently either controlling all the props or none, not much should break. Some of our components let you use the prop in the stateful version as the initial value for that state. The new components do not behave that way. You need to put initial values as keys inside the `initialState` prop.

Here are all the components that are progressively stateful in v4, along with the props that can be controlled.

* Calendar
    * date
* ColorPicker
    * color
    * open
    * internalError
* ConditionalFieldset
    * selectedIndex
* CountrySelector
    * open
    * searchIndex
    * searchString
    * searchTime
* DetailsTooltip
    * open
* ExpandableRow
    * expanded
    * showDeleteConfirm
* FormDropDownList
    * open
    * searchIndex
    * searchString
    * searchTime
* FormTextArea
    * value
* FormTimeZone
    * filterByCountry
    * open
    * searchString
    * selectedIndex
    * value
* PhoneInput
    * open
    * searchIndex
    * searchString
    * searchTime
* LinkDropDownList
    * open
    * selectedOption
* Pagination
    * page
* RockerButton
    * selectedIndex
    * SelectionList
    * queryString
    * showOnlySelected
    * selectedItemIds

## Portals and Popper.js
A portal is a React feature that lets a component render content in another part of the DOM. Popper.js is a library that positions an element in relation to some other element. For v4, we’re using these two features to make our dropdowns and other popout content work better. For the most part, this change should work automatically and make your existing components behave in a new and better way. Because using portals changes the DOM structure, there could be problems with any custom CSS targeting these components. Tests relying on the DOM might also break.

Here are all the components that use portals, poppers, or both.

* AppFrame
* ButtonBar
* Calendar
* ColorPicker
* ConditionalFieldset
* ConfirmTooltip
* CountrySelector
* DetailsTooltip
* ExpandableRow
* FilterSelector
* FormDropDownList
* FormTimeZone
* HeaderBar
* LinkDropDownList
* ModalButton
* MultiDrag
* OverflowMenu
* PopoverMenu
* TimePicker
* TranslationPicker
* UnitInput
* Wizard & Step

## Single-Component Changes
### Button
The v3 button removes the right margin from buttons with the “add” icon. In v4, that margin is removed by setting the `noSpacing` prop rather than targeting an icon.

### ButtonBar
In mockups, the “Discard Changes” button is the dark gray cancel button style while the v3 version of the button bar displays it in the outlined white standard button style. This style has changed in v4.

### ExpandableRow
To display a correctly-styled expandable row in v3, the component must be wrapped in an element with the `result-set` class. In v4, the component has its own class. This shouldn’t create problems unless there’s a conflict with custom CSS.

### FileUpload
In v4, we improved the handling of default image. In particular, the default will no longer take precedence when `thumbnailSrc` is provided.

## CSS Classes, Markup, and Data IDs
In addition to the code changes we made for v4, we are also changing our approach to refactoring components. In v3, we tried to preserve markup and class names so that we wouldn’t break custom CSS or tests. For v4, we are expressly not guaranteeing our class names and markup will remain consistent.

To make sure your application doesn’t break, please remove any styles that target library-generated classes or that rely on a component having a certain DOM structure. We will still support the `className` prop for our components, so you might consider changing your custom styles to use your own custom class name.

To keep your tests working, make sure they target components based on the `data-id` prop instead of class names. We do guarantee consistency for data ids. Read our "Testing Components" documentation to learn more.
