"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.nodeHashArray = exports.NodeFileHasher = void 0;
const tslib_1 = require("tslib");
const workspace_root_1 = require("../../utils/workspace-root");
const perf_hooks_1 = require("perf_hooks");
const path_1 = require("path");
const fs_1 = require("fs");
const file_hasher_base_1 = require("./file-hasher-base");
const strip_indents_1 = require("../../utils/strip-indents");
const path_2 = require("../../utils/path");
const ignore_1 = require("../../utils/ignore");
const path_3 = require("../../utils/path");
const crypto_1 = require("crypto");
class NodeFileHasher extends file_hasher_base_1.FileHasherBase {
    constructor() {
        super(...arguments);
        this.ignoredGlobs = getIgnoredGlobs();
    }
    init() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            perf_hooks_1.performance.mark('init hashing:start');
            this.clear();
            this.allFilesInDir(workspace_root_1.workspaceRoot, true);
            perf_hooks_1.performance.mark('init hashing:end');
            perf_hooks_1.performance.measure('init hashing', 'init hashing:start', 'init hashing:end');
        });
    }
    allFilesInDir(absoluteDirName, recurse = true) {
        const relDirName = (0, path_1.relative)(workspace_root_1.workspaceRoot, absoluteDirName);
        if (relDirName && this.ignoredGlobs.ignores(relDirName)) {
            return;
        }
        try {
            (0, fs_1.readdirSync)(absoluteDirName).forEach((c) => {
                const absoluteChild = (0, path_1.join)(absoluteDirName, c);
                const relChild = (0, path_1.relative)(workspace_root_1.workspaceRoot, absoluteChild);
                if (this.ignoredGlobs.ignores(relChild)) {
                    return;
                }
                try {
                    const s = (0, fs_1.statSync)(absoluteChild);
                    if (s.isFile()) {
                        this.fileHashes.set((0, path_2.normalizePath)(relChild), this.hashFile(relChild));
                    }
                    else if (s.isDirectory() && recurse) {
                        this.allFilesInDir(absoluteChild, true);
                    }
                }
                catch (_a) { }
            });
        }
        catch (_a) { }
    }
    hashFile(path) {
        if (!this.fileHashes) {
            throw new Error('FileHasher is invoked before being initialized');
        }
        const relativePath = (0, path_2.normalizePath)(path.startsWith(workspace_root_1.workspaceRoot)
            ? path.slice(workspace_root_1.workspaceRoot.length + 1)
            : path);
        try {
            // this has to be absolute to avoid issues with cwd
            return this.hashContent((0, fs_1.readFileSync)((0, path_3.joinPathFragments)(workspace_root_1.workspaceRoot, relativePath)));
        }
        catch (_a) {
            return '';
        }
    }
    hashContent(content) {
        const hasher = (0, crypto_1.createHash)('sha256');
        hasher.update(content);
        return hasher.digest('hex');
    }
}
exports.NodeFileHasher = NodeFileHasher;
function nodeHashArray(input) {
    const hasher = (0, crypto_1.createHash)('sha256');
    for (const part of input) {
        // intentional single equals to check for null and undefined
        if (part != undefined) {
            hasher.update(part);
        }
    }
    return hasher.digest('hex');
}
exports.nodeHashArray = nodeHashArray;
function getIgnoredGlobs() {
    const ig = (0, ignore_1.getIgnoreObject)();
    ig.add((0, strip_indents_1.stripIndents) `
      node_modules
      tmp
      dist
      build
    `);
    return ig;
}
