"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hashExternalNodes = exports.mapExternalNodeDependencies = exports.getNodeName = exports.isRootVersion = exports.findMatchingVersion = exports.hashString = exports.sortObject = void 0;
const semver_1 = require("semver");
const hashing_impl_1 = require("../../hasher/hashing-impl");
const workspace_root_1 = require("../workspace-root");
const fs_1 = require("fs");
/**
 * Simple sort function to ensure keys are ordered alphabetically
 * @param obj
 * @returns
 */
function sortObject(obj, valueTransformator = (value) => value, descending = false) {
    const keys = Object.keys(obj);
    if (keys.length === 0) {
        return;
    }
    keys.sort();
    if (descending) {
        keys.reverse();
    }
    const result = {};
    keys.forEach((key) => {
        result[key] = valueTransformator(obj[key]);
    });
    return result;
}
exports.sortObject = sortObject;
/**
 * Apply simple hashing of the content using the default hashing implementation
 * @param fileContent
 * @returns
 */
function hashString(fileContent) {
    return hashing_impl_1.defaultHashing.hashArray([fileContent]);
}
exports.hashString = hashString;
function findMatchingVersion(packageName, packageVersions, version) {
    var _a;
    // if it's fixed version, just return it
    if (packageVersions[`${packageName}@${version}`]) {
        return version;
    }
    // otherwise search for the matching version
    return (_a = Object.values(packageVersions).find((v) => (0, semver_1.satisfies)(v.version, version))) === null || _a === void 0 ? void 0 : _a.version;
}
exports.findMatchingVersion = findMatchingVersion;
function isRootVersion(packageName, version) {
    const fullPath = `${workspace_root_1.workspaceRoot}/node_modules/${packageName}/package.json`;
    if ((0, fs_1.existsSync)(fullPath)) {
        const content = (0, fs_1.readFileSync)(fullPath, 'utf-8');
        return JSON.parse(content).version === version;
    }
    else {
        return false;
    }
}
exports.isRootVersion = isRootVersion;
/**
 * Returns node name depending whether it's root version or nested
 */
function getNodeName(dep, version, rootVersion) {
    return rootVersion ? `npm:${dep}` : `npm:${dep}@${version}`;
}
exports.getNodeName = getNodeName;
function mapExternalNodeDependencies(nodeName, packageVersion, dependencies, versionCache) {
    const result = [];
    const combinedDependencies = packageVersion.dependencies || packageVersion.peerDependencies
        ? Object.assign(Object.assign({}, (packageVersion.dependencies || {})), (packageVersion.peerDependencies || {})) : undefined;
    const transitiveDeps = mapTransitiveDependencies(dependencies, combinedDependencies, versionCache);
    // map transitive dependencies to dependencies hash map
    transitiveDeps.forEach((dep) => {
        result.push({
            type: 'static',
            source: nodeName,
            target: dep,
        });
    });
    return result;
}
exports.mapExternalNodeDependencies = mapExternalNodeDependencies;
// Finds the maching version of each dependency of the package and
// maps each {package}:{versionRange} pair to "npm:{package}@{version}" (when transitive) or "npm:{package}" (when root)
function mapTransitiveDependencies(packages, dependencies, versionCache) {
    if (!dependencies) {
        return [];
    }
    const result = [];
    Object.keys(dependencies).forEach((packageName) => {
        var _a;
        const cleanVersion = dependencies[packageName].split('_')[0];
        const key = `${packageName}@${cleanVersion}`;
        // some of the peer dependencies might not be installed,
        // we don't have them as nodes in externalNodes
        // so there's no need to map them as dependencies
        if (!packages[packageName]) {
            return;
        }
        // if we already processed this dependency, use the version from the cache
        if (versionCache[key]) {
            result.push(versionCache[key]);
        }
        else {
            const versions = packages[packageName];
            const version = findMatchingVersion(packageName, versions, cleanVersion);
            // for some peer dependencies, we won't find installed version so we'll just ignore those
            if (version) {
                const nodeName = getNodeName(packageName, version, (_a = versions[`${packageName}@${version}`]) === null || _a === void 0 ? void 0 : _a.rootVersion);
                result.push(nodeName);
                versionCache[key] = nodeName;
            }
        }
    });
    return result;
}
function hashExternalNodes(projectGraph) {
    Object.keys(projectGraph.externalNodes).forEach((key) => {
        if (!projectGraph.externalNodes[key].data.hash) {
            // hash it using it's dependencies
            hashExternalNode(projectGraph.externalNodes[key], projectGraph);
        }
    });
}
exports.hashExternalNodes = hashExternalNodes;
function hashExternalNode(node, graph) {
    const hashKey = `${node.data.packageName}@${node.data.version}`;
    if (!graph.dependencies[node.name]) {
        node.data.hash = hashString(hashKey);
    }
    else {
        const hashingInput = [hashKey];
        traverseExternalNodesDependencies(node.name, graph, hashingInput);
        node.data.hash = hashing_impl_1.defaultHashing.hashArray(hashingInput.sort());
    }
}
function traverseExternalNodesDependencies(projectName, graph, visited) {
    graph.dependencies[projectName].forEach((d) => {
        const target = graph.externalNodes[d.target];
        const targetKey = `${target.data.packageName}@${target.data.version}`;
        if (visited.indexOf(targetKey) === -1) {
            visited.push(targetKey);
            if (graph.dependencies[d.target]) {
                traverseExternalNodesDependencies(d.target, graph, visited);
            }
        }
    });
}
//# sourceMappingURL=utils.js.map