"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pruneLockFile = exports.writeLockFile = exports.mapLockFileDataToPartialGraph = exports.parseLockFile = exports.lockFileHash = exports.lockFileExists = void 0;
const fs_extra_1 = require("fs-extra");
const package_manager_1 = require("../package-manager");
const yarn_1 = require("./yarn");
const npm_1 = require("./npm");
const pnpm_1 = require("./pnpm");
const workspace_root_1 = require("../workspace-root");
const path_1 = require("path");
const utils_1 = require("./utils");
const fs_1 = require("fs");
const YARN_LOCK_PATH = (0, path_1.join)(workspace_root_1.workspaceRoot, 'yarn.lock');
const NPM_LOCK_PATH = (0, path_1.join)(workspace_root_1.workspaceRoot, 'package-lock.json');
const PNPM_LOCK_PATH = (0, path_1.join)(workspace_root_1.workspaceRoot, 'pnpm-lock.yaml');
/**
 * Check if lock file exists
 */
function lockFileExists(packageManager = (0, package_manager_1.detectPackageManager)(workspace_root_1.workspaceRoot)) {
    if (packageManager === 'yarn') {
        return (0, fs_1.existsSync)(YARN_LOCK_PATH);
    }
    if (packageManager === 'pnpm') {
        return (0, fs_1.existsSync)(PNPM_LOCK_PATH);
    }
    if (packageManager === 'npm') {
        return (0, fs_1.existsSync)(NPM_LOCK_PATH);
    }
    throw Error(`Unknown package manager ${packageManager} or lock file missing`);
}
exports.lockFileExists = lockFileExists;
/**
 * Hashes lock file content
 */
function lockFileHash(packageManager = (0, package_manager_1.detectPackageManager)(workspace_root_1.workspaceRoot)) {
    let file;
    if (packageManager === 'yarn') {
        file = (0, fs_extra_1.readFileSync)(YARN_LOCK_PATH, 'utf8');
    }
    if (packageManager === 'pnpm') {
        file = (0, fs_extra_1.readFileSync)(PNPM_LOCK_PATH, 'utf8');
    }
    if (packageManager === 'npm') {
        file = (0, fs_extra_1.readFileSync)(NPM_LOCK_PATH, 'utf8');
    }
    if (file) {
        return (0, utils_1.hashString)(file);
    }
    else {
        throw Error(`Unknown package manager ${packageManager} or lock file missing`);
    }
}
exports.lockFileHash = lockFileHash;
/**
 * Parses lock file and maps dependencies and metadata to {@link LockFileData}
 */
function parseLockFile(packageManager = (0, package_manager_1.detectPackageManager)(workspace_root_1.workspaceRoot)) {
    if (packageManager === 'yarn') {
        const file = (0, fs_extra_1.readFileSync)(YARN_LOCK_PATH, 'utf8');
        return (0, yarn_1.parseYarnLockFile)(file);
    }
    if (packageManager === 'pnpm') {
        const file = (0, fs_extra_1.readFileSync)(PNPM_LOCK_PATH, 'utf8');
        return (0, pnpm_1.parsePnpmLockFile)(file);
    }
    if (packageManager === 'npm') {
        const file = (0, fs_extra_1.readFileSync)(NPM_LOCK_PATH, 'utf8');
        return (0, npm_1.parseNpmLockFile)(file);
    }
    throw Error(`Unknown package manager: ${packageManager}`);
}
exports.parseLockFile = parseLockFile;
/**
 * Maps lock file data to {@link ProjectGraphExternalNode} hash map
 * @param lockFileData
 * @returns
 */
function mapLockFileDataToPartialGraph(lockFileData) {
    const result = {
        dependencies: {},
        externalNodes: {},
        nodes: {},
    };
    const versionCache = {};
    Object.keys(lockFileData.dependencies).forEach((dep) => {
        const versions = lockFileData.dependencies[dep];
        Object.keys(versions).forEach((nameVersion) => {
            const packageVersion = versions[nameVersion];
            // save external node
            const nodeName = (0, utils_1.getNodeName)(dep, packageVersion.version, packageVersion.rootVersion);
            result.externalNodes[nodeName] = {
                type: 'npm',
                name: nodeName,
                data: {
                    version: packageVersion.version,
                    packageName: dep,
                },
            };
            const dependencies = (0, utils_1.mapExternalNodeDependencies)(nodeName, packageVersion, lockFileData.dependencies, versionCache);
            if (dependencies.length) {
                result.dependencies[nodeName] = dependencies;
            }
        });
    });
    (0, utils_1.hashExternalNodes)(result);
    return result;
}
exports.mapLockFileDataToPartialGraph = mapLockFileDataToPartialGraph;
/**
 * Stringifies {@link LockFileData} content and writes it to lock file
 */
function writeLockFile(lockFile, packageManager = (0, package_manager_1.detectPackageManager)(workspace_root_1.workspaceRoot)) {
    if (packageManager === 'yarn') {
        const content = (0, yarn_1.stringifyYarnLockFile)(lockFile);
        (0, fs_extra_1.writeFileSync)(YARN_LOCK_PATH, content);
        return;
    }
    if (packageManager === 'pnpm') {
        const content = (0, pnpm_1.stringifyPnpmLockFile)(lockFile);
        (0, fs_extra_1.writeFileSync)(PNPM_LOCK_PATH, content);
        return;
    }
    if (packageManager === 'npm') {
        const content = (0, npm_1.stringifyNpmLockFile)(lockFile);
        (0, fs_extra_1.writeFileSync)(NPM_LOCK_PATH, content);
        return;
    }
    throw Error(`Unknown package manager: ${packageManager}`);
}
exports.writeLockFile = writeLockFile;
/**
 * Prunes {@link LockFileData} based on minimal necessary set of packages
 * Returns new {@link LockFileData}
 */
function pruneLockFile(lockFile, packages, packageManager = (0, package_manager_1.detectPackageManager)(workspace_root_1.workspaceRoot)) {
    if (packageManager === 'yarn') {
        return (0, yarn_1.pruneYarnLockFile)(lockFile, packages);
    }
    if (packageManager === 'pnpm') {
        return (0, pnpm_1.prunePnpmLockFile)(lockFile, packages);
    }
    if (packageManager === 'npm') {
        return (0, npm_1.pruneNpmLockFile)(lockFile, packages);
    }
    throw Error(`Unknown package manager: ${packageManager}`);
}
exports.pruneLockFile = pruneLockFile;
//# sourceMappingURL=lock-file.js.map