"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pruneNpmLockFile = exports.stringifyNpmLockFile = exports.parseNpmLockFile = void 0;
const tslib_1 = require("tslib");
const utils_1 = require("./utils");
/**
 * Parses package-lock.json file to `LockFileData` object
 *
 * @param lockFile
 * @returns
 */
function parseNpmLockFile(lockFile) {
    const _a = JSON.parse(lockFile), { packages, dependencies } = _a, metadata = tslib_1.__rest(_a, ["packages", "dependencies"]);
    return {
        dependencies: mapPackages(dependencies, packages),
        lockFileMetadata: Object.assign({ metadata }, (packages && { rootPackage: packages[''] })),
        hash: (0, utils_1.hashString)(lockFile),
    };
}
exports.parseNpmLockFile = parseNpmLockFile;
// Maps /node_modules/@abc/def with version 1.2.3 => @abc/def > @abc/dev@1.2.3
function mapPackages(dependencies, packages) {
    const mappedPackages = {};
    Object.entries(dependencies).forEach(([packageName, value]) => {
        mappedPackages[packageName] = mappedPackages[packageName] || {};
        const packagePath = `node_modules/${packageName}`;
        const newKey = packageName + '@' + value.version;
        mappedPackages[packageName][newKey] = mapDependency(packagePath, value, true, packages && { packageData: packages[packagePath] });
        mapPackageDependencies(mappedPackages, packages, value.dependencies, packagePath);
    });
    return mappedPackages;
}
function mapDependency(packagePath, _a, rootVersion, packageData) {
    var { dev, optional } = _a, value = tslib_1.__rest(_a, ["dev", "optional"]);
    const packageMeta = Object.assign({ path: packagePath, dev,
        optional }, packageData);
    return Object.assign(Object.assign({}, value), { 
        // invert those two fields to match other package managers
        requires: value.dependencies, dependencies: value.requires, packageMeta: [packageMeta], rootVersion });
}
function mapPackageDependencies(mappedPackages, packages, dependencies, parentPath) {
    if (!dependencies) {
        return;
    }
    Object.entries(dependencies).forEach(([packageName, value]) => {
        mappedPackages[packageName] = mappedPackages[packageName] || {};
        const packagePath = `${parentPath}/node_modules/${packageName}`;
        const newKey = packageName + '@' + value.version;
        if (mappedPackages[packageName][newKey]) {
            mappedPackages[packageName][newKey].packageMeta.push(Object.assign({ path: packagePath, dev: value.dev, optional: value.optional }, (packages && { packageData: packages[packagePath] })));
        }
        else {
            mappedPackages[packageName][newKey] = mapDependency(packagePath, value, false, packages && { packageData: packages[packagePath] });
        }
        mapPackageDependencies(mappedPackages, packages, value.dependencies, packagePath);
    });
}
/**
 * Generates package-lock.json file from `LockFileData` object
 *
 * @param lockFile
 * @returns
 */
function stringifyNpmLockFile(lockFileData) {
    const dependencies = {};
    const isV2 = lockFileData.lockFileMetadata.metadata.lockfileVersion > 1;
    const packages = Object.assign({}, (isV2 && { '': lockFileData.lockFileMetadata.rootPackage }));
    const keys = Object.keys(lockFileData.dependencies);
    for (let i = 0; i < keys.length; i++) {
        const packageName = keys[i];
        const packageVersions = lockFileData.dependencies[packageName];
        const values = Object.values(packageVersions);
        values.forEach((value) => {
            if (isV2) {
                unmapPackage(packages, value);
            }
            unmapPackageDependencies(dependencies, packageName, value);
        });
    }
    // generate package lock JSON
    const lockFileJson = Object.assign(Object.assign(Object.assign({}, lockFileData.lockFileMetadata.metadata), (isV2 && { packages: (0, utils_1.sortObject)(packages) })), { dependencies: sortDependencies(dependencies) });
    return JSON.stringify(lockFileJson, null, 2) + '\n';
}
exports.stringifyNpmLockFile = stringifyNpmLockFile;
// remapping the package back to package-lock format
function unmapPackage(packages, { packageMeta }) {
    // we need to decompose value, to achieve particular field ordering
    for (let i = 0; i < packageMeta.length; i++) {
        const { path, packageData } = packageMeta[i];
        // we are sorting the properties to get as close as possible to the original package-lock.json
        packages[path] = packageData;
    }
}
function unmapPackageDependencies(dependencies, packageName, _a) {
    var { packageMeta } = _a, value = tslib_1.__rest(_a, ["packageMeta"]);
    const { version, resolved, integrity, devOptional } = value;
    for (let i = 0; i < packageMeta.length; i++) {
        const { path, dev, optional } = packageMeta[i];
        const projectPath = path.split('node_modules/').slice(1);
        const innerDeps = getProjectNodeAndEnsureParentHierarchy(projectPath, dependencies);
        const requires = unmapDependencyRequires(value);
        // sorting fields to match package-lock structure
        innerDeps[packageName] = Object.assign({ version,
            resolved,
            integrity,
            dev,
            devOptional,
            optional,
            requires }, innerDeps[packageName]);
    }
}
// generates/ensures entire parent hierarchy exists for the given project path
// returns pointer to last project in the path
function getProjectNodeAndEnsureParentHierarchy(projects, dependencies) {
    while (projects.length > 1) {
        const parentName = projects.shift().replace(/\/$/, '');
        if (!dependencies[parentName]) {
            dependencies[parentName] = {};
        }
        if (!dependencies[parentName].dependencies) {
            dependencies[parentName].dependencies = {};
        }
        dependencies = dependencies[parentName].dependencies;
    }
    return dependencies;
}
// combine dependencies and optionalDependencies into requires and sort them
function unmapDependencyRequires(value) {
    if (!value.dependencies && !value.optionalDependencies) {
        return undefined;
    }
    const dependencies = Object.assign(Object.assign({}, (value.dependencies || {})), (value.optionalDependencies || {}));
    const sortedKeys = Object.keys(dependencies).sort();
    const result = {};
    for (let i = 0; i < sortedKeys.length; i++) {
        const key = sortedKeys[i];
        result[key] = dependencies[key];
    }
    return result;
}
// recursively sort dependencies
function sortDependencies(unsortedDependencies) {
    const dependencies = {};
    const sortedKeys = Object.keys(unsortedDependencies).sort();
    for (let i = 0; i < sortedKeys.length; i++) {
        const value = unsortedDependencies[sortedKeys[i]];
        dependencies[sortedKeys[i]] = value;
        if (value.dependencies) {
            value.dependencies = sortDependencies(value.dependencies);
        }
    }
    return dependencies;
}
/**
 * Prunes the lock file data based on the list of packages and their transitive dependencies
 *
 * @param lockFileData
 * @returns
 */
function pruneNpmLockFile(lockFileData, packages) {
    // todo(meeroslav): This functionality has not been implemented yet
    console.warn('Pruning package-lock.json is not yet implemented. Returning entire lock file');
    return lockFileData;
}
exports.pruneNpmLockFile = pruneNpmLockFile;
//# sourceMappingURL=npm.js.map