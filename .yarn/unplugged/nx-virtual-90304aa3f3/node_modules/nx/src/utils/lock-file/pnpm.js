"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.prunePnpmLockFile = exports.stringifyPnpmLockFile = exports.parsePnpmLockFile = void 0;
const tslib_1 = require("tslib");
const js_yaml_1 = require("@zkochan/js-yaml");
const utils_1 = require("./utils");
const LOCKFILE_YAML_FORMAT = {
    blankLines: true,
    lineWidth: 1000,
    noCompatMode: true,
    noRefs: true,
    sortKeys: false,
};
/**
 * Parses pnpm-lock.yaml file to `LockFileData` object
 *
 * @param lockFile
 * @returns
 */
function parsePnpmLockFile(lockFile) {
    const data = (0, js_yaml_1.load)(lockFile);
    const { dependencies, devDependencies, packages, specifiers } = data, metadata = tslib_1.__rest(data, ["dependencies", "devDependencies", "packages", "specifiers"]);
    return {
        dependencies: mapPackages(dependencies, devDependencies, specifiers, packages, metadata.lockfileVersion.toString().endsWith('inlineSpecifiers')),
        lockFileMetadata: Object.assign({}, metadata),
        hash: (0, utils_1.hashString)(lockFile),
    };
}
exports.parsePnpmLockFile = parsePnpmLockFile;
function mapPackages(dependencies, devDependencies, specifiers, packages, inlineSpecifiers) {
    const mappedPackages = {};
    Object.entries(packages).forEach(([key, value]) => {
        // construct packageMeta object
        const meta = mapMetaInformation({ dependencies, devDependencies, specifiers }, inlineSpecifiers, key, value);
        // create new key
        const version = key.split('/').pop().split('_')[0];
        const packageName = key.slice(1, key.lastIndexOf('/'));
        const newKey = `${packageName}@${version}`;
        if (!mappedPackages[packageName]) {
            mappedPackages[packageName] = {};
        }
        if (mappedPackages[packageName][newKey]) {
            mappedPackages[packageName][newKey].packageMeta.push(meta);
        }
        else {
            mappedPackages[packageName][newKey] = Object.assign(Object.assign({}, value), { version, packageMeta: [meta] });
        }
    });
    Object.keys(mappedPackages).forEach((packageName) => {
        const versions = mappedPackages[packageName];
        const versionKeys = Object.keys(versions);
        if (versionKeys.length === 1) {
            versions[versionKeys[0]].rootVersion = true;
        }
        else {
            const rootVersionKey = versionKeys.find((v) => (0, utils_1.isRootVersion)(packageName, versions[v].version));
            // this should never happen, but just in case
            if (rootVersionKey) {
                versions[rootVersionKey].rootVersion = true;
            }
        }
    });
    return mappedPackages;
}
// maps packageMeta based on dependencies, devDependencies and (inline) specifiers
function mapMetaInformation({ dependencies, devDependencies, specifiers, }, hasInlineSpefiers, key, dependencyDetails) {
    const matchingVersion = key.split('/').pop();
    const packageName = key.slice(1, key.lastIndexOf('/'));
    const isDependency = isVersionMatch(dependencies === null || dependencies === void 0 ? void 0 : dependencies[packageName], matchingVersion, hasInlineSpefiers);
    const isDevDependency = isVersionMatch(devDependencies === null || devDependencies === void 0 ? void 0 : devDependencies[packageName], matchingVersion, hasInlineSpefiers);
    let specifier;
    if (isDependency || isDevDependency) {
        if (hasInlineSpefiers) {
            specifier =
                getSpecifier(dependencies === null || dependencies === void 0 ? void 0 : dependencies[packageName]) ||
                    getSpecifier(devDependencies === null || devDependencies === void 0 ? void 0 : devDependencies[packageName]);
        }
        else {
            if (isDependency || isDevDependency) {
                specifier = specifiers[packageName];
            }
        }
    }
    return {
        key,
        isDependency,
        isDevDependency,
        specifier,
        dependencyDetails: Object.assign(Object.assign({}, (dependencyDetails.dependencies && {
            dependencies: dependencyDetails.dependencies,
        })), (dependencyDetails.peerDependencies && {
            peerDependencies: dependencyDetails.peerDependencies,
        })),
    };
}
// version match for dependencies w/ or w/o inline specifier
function isVersionMatch(versionInfo, matchingVersion, hasInlineSpefiers) {
    if (!versionInfo) {
        return false;
    }
    if (!hasInlineSpefiers) {
        return versionInfo === matchingVersion;
    }
    return (versionInfo.version === matchingVersion);
}
function getSpecifier(versionInfo) {
    return (versionInfo && versionInfo.specifier);
}
/**
 * Generates pnpm-lock.yml file from `LockFileData` object
 *
 * @param lockFile
 * @returns
 */
function stringifyPnpmLockFile(lockFileData) {
    const pnpmLockFile = unmapLockFile(lockFileData);
    return (0, js_yaml_1.dump)(pnpmLockFile, LOCKFILE_YAML_FORMAT);
}
exports.stringifyPnpmLockFile = stringifyPnpmLockFile;
// revert lock file to it's original state
function unmapLockFile(lockFileData) {
    const devDependencies = {};
    const dependencies = {};
    const packages = {};
    const specifiers = {};
    const inlineSpecifiers = lockFileData.lockFileMetadata.lockfileVersion
        .toString()
        .endsWith('inlineSpecifiers');
    const packageNames = Object.keys(lockFileData.dependencies);
    for (let i = 0; i < packageNames.length; i++) {
        const packageName = packageNames[i];
        const versions = Object.values(lockFileData.dependencies[packageName]);
        versions.forEach((_a) => {
            var { packageMeta, version: _, rootVersion } = _a, rest = tslib_1.__rest(_a, ["packageMeta", "version", "rootVersion"]);
            packageMeta.forEach((meta) => {
                const { key, specifier } = meta;
                let version;
                if (inlineSpecifiers) {
                    version = { specifier, version: key.slice(key.lastIndexOf('/') + 1) };
                }
                else {
                    version = key.slice(key.lastIndexOf('/') + 1);
                    if (specifier) {
                        specifiers[packageName] = specifier;
                    }
                }
                if (meta.isDependency) {
                    dependencies[packageName] = version;
                }
                if (meta.isDevDependency) {
                    devDependencies[packageName] = version;
                }
                packages[key] = Object.assign(Object.assign({}, rest), meta.dependencyDetails);
            });
        });
    }
    return Object.assign(Object.assign({}, lockFileData.lockFileMetadata), { specifiers: (0, utils_1.sortObject)(specifiers), dependencies: (0, utils_1.sortObject)(dependencies), devDependencies: (0, utils_1.sortObject)(devDependencies), packages: (0, utils_1.sortObject)(packages) });
}
/**
 * Prunes the lock file data based on the list of packages and their transitive dependencies
 *
 * @param lockFileData
 * @returns
 */
function prunePnpmLockFile(lockFileData, packages) {
    // todo(meeroslav): This functionality has not been implemented yet
    console.warn('Pruning pnpm-lock.yaml is not yet implemented. Returning entire lock file');
    return lockFileData;
}
exports.prunePnpmLockFile = prunePnpmLockFile;
//# sourceMappingURL=pnpm.js.map