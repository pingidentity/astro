"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pruneYarnLockFile = exports.stringifyYarnLockFile = exports.parseYarnLockFile = void 0;
const tslib_1 = require("tslib");
const parsers_1 = require("@yarnpkg/parsers");
const lockfile_1 = require("@yarnpkg/lockfile");
const utils_1 = require("./utils");
const BERRY_LOCK_FILE_DISCLAIMER = `# This file was generated by Nx. Do not edit this file directly\n# Manual changes might be lost - proceed with caution!\n\n`;
/**
 * Parses `yarn.lock` syml file and maps to {@link LockFileData}
 *
 * @param lockFile
 * @returns
 */
function parseYarnLockFile(lockFile) {
    const _a = (0, parsers_1.parseSyml)(lockFile), { __metadata } = _a, dependencies = tslib_1.__rest(_a, ["__metadata"]);
    // Yarn Berry has workspace packages includes, so we need to extract those to metadata
    const [mappedPackages, workspacePackages] = mapPackages(dependencies);
    const isBerry = !!__metadata;
    const hash = (0, utils_1.hashString)(lockFile);
    if (isBerry) {
        return {
            dependencies: mappedPackages,
            lockFileMetadata: {
                __metadata,
                workspacePackages,
            },
            hash,
        };
    }
    else {
        return { dependencies: mappedPackages, hash };
    }
}
exports.parseYarnLockFile = parseYarnLockFile;
// map original yarn packages to the LockFileData structure
function mapPackages(packages) {
    const mappedPackages = {};
    const workspacePackages = {};
    Object.entries(packages).forEach(([keyExpr, value]) => {
        // separate workspace packages from the external ones
        // we only combine them back when stringifying
        if (value.linkType === 'soft') {
            workspacePackages[keyExpr] = value;
        }
        else {
            // key might be "@nrwl/somedep@1.2.3, @nrwl/somedep@^1.0.0..."
            const keys = keyExpr.split(', ');
            const packageName = keys[0].slice(0, keys[0].lastIndexOf('@'));
            const newKey = `${packageName}@${value.version}`;
            mappedPackages[packageName] = mappedPackages[packageName] || {};
            if (!mappedPackages[packageName][newKey]) {
                mappedPackages[packageName][newKey] = Object.assign(Object.assign({}, value), { packageMeta: keys });
            }
            else {
                mappedPackages[packageName][newKey].packageMeta.push(...keys);
            }
        }
    });
    Object.keys(mappedPackages).forEach((packageName) => {
        const versions = mappedPackages[packageName];
        const versionKeys = Object.keys(versions);
        if (versionKeys.length === 1) {
            versions[versionKeys[0]].rootVersion = true;
        }
        else {
            const rootVersionKey = versionKeys.find((v) => (0, utils_1.isRootVersion)(packageName, versions[v].version));
            // this should never happen, but just in case
            if (rootVersionKey) {
                versions[rootVersionKey].rootVersion = true;
            }
        }
    });
    return [mappedPackages, workspacePackages];
}
/**
 * Generates yarn.lock file from `LockFileData` object
 *
 * @param lockFileData
 * @returns
 */
function stringifyYarnLockFile(lockFileData) {
    var _a;
    // only berry's format has metadata defined
    // this is an easy way to distinguish it from the classic
    const isBerry = !!((_a = lockFileData.lockFileMetadata) === null || _a === void 0 ? void 0 : _a.__metadata);
    const dependencies = unmapPackages(lockFileData.dependencies, isBerry);
    if (isBerry) {
        const lockFile = Object.assign(Object.assign({ __metadata: lockFileData.lockFileMetadata.__metadata }, lockFileData.lockFileMetadata.workspacePackages), dependencies);
        // berry's stringifySyml doesn't generate comment
        return BERRY_LOCK_FILE_DISCLAIMER + (0, parsers_1.stringifySyml)(lockFile);
    }
    else {
        return (0, lockfile_1.stringify)(dependencies);
    }
}
exports.stringifyYarnLockFile = stringifyYarnLockFile;
// revert mapping of packages from LockFileData to the original JSON structure
// E.g. from:
//  "abc": {
//    "abc@1.2.3": {
//      ...value
//      packageMeta: ["abc@^1.0.0", "abc@~1.2.0"]
//    }
// }
// to:
//  "abc@^1.0.0, abc@~1.2.0": {
//    ...value
//  }
//
function unmapPackages(dependencies, isBerry = false) {
    const packages = {};
    Object.values(dependencies).forEach((packageVersions) => {
        Object.values(packageVersions).forEach((value) => {
            const { packageMeta, rootVersion } = value, rest = tslib_1.__rest(value, ["packageMeta", "rootVersion"]);
            if (isBerry) {
                // berry's `stringifySyml` does not combine packages
                // we have to do it manually
                packages[packageMeta.join(', ')] = rest;
            }
            else {
                // classic's `stringify` combines packages with same resolution
                packageMeta.forEach((key) => {
                    packages[key] = rest;
                });
            }
        });
    });
    return packages;
}
/**
 * Prunes the lock file data based on the list of packages and their transitive dependencies
 *
 * @param lockFileData
 * @returns
 */
function pruneYarnLockFile(lockFileData, packages) {
    var _a;
    const isBerry = !!((_a = lockFileData.lockFileMetadata) === null || _a === void 0 ? void 0 : _a.__metadata);
    const prunedDependencies = pruneDependencies(lockFileData.dependencies, packages);
    let prunedLockFileData;
    if (isBerry) {
        const { __metadata, workspacePackages } = lockFileData.lockFileMetadata;
        prunedLockFileData = {
            lockFileMetadata: {
                __metadata,
                workspacePackages: pruneWorkspacePackages(workspacePackages, prunedDependencies, packages),
            },
            dependencies: prunedDependencies,
            hash: '',
        };
    }
    else {
        prunedLockFileData = { dependencies: prunedDependencies, hash: '' };
    }
    prunedLockFileData.hash = (0, utils_1.hashString)(JSON.stringify(prunedLockFileData));
    return prunedLockFileData;
}
exports.pruneYarnLockFile = pruneYarnLockFile;
// iterate over packages to collect the affected tree of dependencies
function pruneDependencies(dependencies, packages) {
    const result = {};
    packages.forEach((packageName) => {
        if (dependencies[packageName]) {
            // take the first version of the package as the default
            const [key, value] = Object.entries(dependencies[packageName])[0];
            result[packageName] = result[packageName] || {};
            result[packageName][key] = value;
            pruneTransitiveDependencies(dependencies, result, value);
        }
        else {
            console.warn(`Could not find ${packageName} in the lock file. Skipping...`);
        }
    });
    return result;
}
// find all transitive dependencies of already pruned packages
// and adds them to the collection
// recursively prunes their dependencies
function pruneTransitiveDependencies(dependencies, prunedDeps, value) {
    if (!value.dependencies) {
        return;
    }
    Object.entries(value.dependencies).forEach(([packageName, version]) => {
        if (dependencies[packageName]) {
            // check if package with given version exists in data
            // if yes, return key, value and version expression from packageMeta
            const dependencyTriplet = findDependencyTriplet(dependencies[packageName], packageName, version);
            if (dependencyTriplet) {
                const [key, _a, metaVersion] = dependencyTriplet, { packageMeta } = _a, value = tslib_1.__rest(_a, ["packageMeta"]);
                if (!prunedDeps[packageName]) {
                    prunedDeps[packageName] = {};
                }
                if (prunedDeps[packageName][key]) {
                    const packageMeta = prunedDeps[packageName][key].packageMeta;
                    if (packageMeta.indexOf(metaVersion) === -1) {
                        packageMeta.push(metaVersion);
                        packageMeta.sort();
                    }
                }
                else {
                    prunedDeps[packageName][key] = Object.assign(Object.assign({}, value), { packageMeta: [metaVersion] });
                    // recurively collect dependencies
                    pruneTransitiveDependencies(dependencies, prunedDeps, prunedDeps[packageName][key]);
                }
            }
        }
    });
}
// prune dependencies of workspace packages from the lockFileMeta
function pruneWorkspacePackages(workspacePackages, prunedDependencies, packages) {
    const result = {};
    Object.entries(workspacePackages).forEach((_a) => {
        var [packageKey, _b] = _a, { dependencies } = _b, value = tslib_1.__rest(_b, ["dependencies"]);
        const isRootPackage = packageKey.indexOf('@workspace:.') !== -1;
        const prunedWorkspaceDependencies = pruneWorkspacePackageDependencies(dependencies, packages, prunedDependencies, isRootPackage);
        result[packageKey] = Object.assign(Object.assign({}, value), { dependencies: (0, utils_1.sortObject)(prunedWorkspaceDependencies) });
    });
    return result;
}
function pruneWorkspacePackageDependencies(dependencies, packages, prunedDependencies, isRoot) {
    const result = {};
    Object.entries(dependencies).forEach(([packageName, packageVersion]) => {
        if (isPackageVersionMatch(prunedDependencies[packageName], packageName, packageVersion)) {
            result[packageName] = packageVersion;
        }
    });
    // add all missing deps to root workspace package
    if (isRoot) {
        packages.forEach((p) => {
            if (!result[p]) {
                // extract first version expression from package's structure
                const metaVersion = Object.values(prunedDependencies[p])[0]
                    .packageMeta[0];
                result[p] = metaVersion.split('@npm:')[1];
            }
        });
    }
    return result;
}
// check if package with given version exists in pruned dependencies
function isPackageVersionMatch(packageVersions, packageName, packageVersion) {
    if (!packageVersions) {
        return false;
    }
    const versionExpr = `${packageName}@${packageVersion}`;
    const berryVersionExpr = `${packageName}@npm:${packageVersion}`;
    const values = Object.values(packageVersions);
    for (let i = 0; i < values.length; i++) {
        if (values[i].packageMeta.includes(versionExpr) ||
            values[i].packageMeta.includes(berryVersionExpr)) {
            return true;
        }
    }
    return false;
}
// find version of the package in LockFileData that matches given depVersion expression
// returns [package@version, packageValue, package@npm:version]
// for berry, the third parameter is different so we return it as well
function findDependencyTriplet(dependency, packageName, version) {
    const entries = Object.entries(dependency);
    for (let i = 0; i < entries.length; i++) {
        const [key, value] = entries[i];
        let metaVersion = `${packageName}@${version}`;
        if (value.packageMeta.includes(metaVersion)) {
            return [key, value, metaVersion];
        }
        // for berry, meta version starts with 'npm:'
        metaVersion = `${packageName}@npm:${version}`;
        if (value.packageMeta.includes(metaVersion)) {
            return [key, value, metaVersion];
        }
    }
    return;
}
//# sourceMappingURL=yarn.js.map