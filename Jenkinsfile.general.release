#!/usr/bin/env groovy
@Library(['jenkins-ci-library']) _
// https://gitlab.corp.pingidentity.com/devtools/icecream/jenkins-ci-library

import groovy.json.JsonOutput

def centralCluster = 'central'
def testCluster = 'test'

// Schema Form NPM publish stuff
def configuration = [
  vaultUrl: 'https://prod-vault-us-east-2.awscloud.pingidentity.net',
  vaultCredentialId: 'jenkins-icecream-pipeline',
  engineVersion: 2
]
def secrets = [
  [
    path: 'secret/central/jenkins-icecream/ux/pingux',
    engineVersion: 2,
    secretValues: [
      [envVar: 'NPM_TOKEN', vaultKey: 'NPM_TOKEN']
    ]
  ]
]

// Logic utils
def globalCdnMap = [
  'ui-library': 'packages/ui-library/cdn',
  '@pingux/end-user': 'packages/end-user/cdn',
  '@pingux/icons': 'packages/icons/cdn',
  '@pingux/branding-themes': 'packages/branding-themes/build/cdn'
];
def updatedPackagesMap = [:];

def generateSlackMessage(packageName, packagePathName, packageVersion) {
  return """
    :tada: ${packageName} ${packageVersion} has been released!
    
    <https://gitlab.corp.pingidentity.com/ux/pingux/-/blob/master/packages/${packagePathName}/CHANGELOG.md|See the CHANGELOG for more details>
  """.stripIndent()
}

pipeline {
  agent {
    kubernetes (
      agentDefinition(
        name: 'ui-library-agent',
        cloud: centralCluster,
        yaml: """
        apiVersion: v1
        kind: Pod
        metadata:
          name: ui-library-agent
        spec:
          containers:
            - name: "ui-library-admin"
              command: # Jenkinsfile overwrites this, but k8s spec requires it
              - cat
              image: "docker.corp.pingidentity.com:5000/testing/ui-library-admin:1.2"
              imagePullPolicy: Always
              workingDir: "/home/jenkins/agent"
              tty: true"""
      )
    )
  }
  parameters {
    string(name: 'LERNA_VERSION_FLAGS', defaultValue: '--yes --conventional-commits --conventional-graduate=@pingux/astro,@pingux/branding-themes,@pingux/end-user,@pingux/flow-diagram,@pingux/icons,@pingux/schema-form,ui-library', description: 'Flags applied to the `lerna version` command.')
    string(name: 'LERNA_PUBLISH_FLAGS', defaultValue: 'from-package --yes --registry https://art01.corp.pingidentity.com/artifactory/api/npm/npm-virtual/', description: 'Flags applied to the `lerna publish` command.')
  }
  environment {
    PING_TEAM_NAME = "ux"
  }
  stages {
    stage('install and link') {
      steps {
        dir("${env.WORKSPACE}") {
          container('ui-library-admin') {
            echo "Installing and linking packages"
            sh "yarn --frozen-lockfile --ignore-engines"
            sh "yarn lerna run build"
          }
        }
        stash includes: 'packages/**/*', excludes: '**/node_modules/**', name: 'packages'
      }
    }

    stage('build-test-lint') {
      steps {
        container('ui-library-admin') {
          sh """
            yarn --frozen-lockfile
            git log -1 --pretty=%B | npx commitlint
            lerna run build
            lerna run lint
            lerna run coverage-ci
          """
        }
      }
    }

    stage('backstop') {
      when {
        beforeAgent true
        expression {  
          sh(returnStatus: true, script: 'git diff origin/master --name-only | grep "^packages/ui-library/.*"' ) == 0
        }
        changeRequest()
      }
      steps {
        container('ui-library-admin') {
          sh """
            yarn --frozen-lockfile
            lerna run demo --scope ui-library
            lerna run backstop-ci
          """
        }
      }
    }

    stage('version') {
      steps {
        dir("${env.WORKSPACE}") {
          container('ui-library-admin') {
            echo "Versioning packages"
            withCredentials([
              sshUserPrivateKey(credentialsId: "jenkins-build-user", keyFileVariable: 'bldUserKeyPath')
            ]) {
              sh """
                git config --global user.email 'devtools+jenkins@pingidentity.com'
                git config --global user.name 'devtools-jenkins'
                GIT_SSH_COMMAND='ssh -o StrictHostKeyChecking=no -i ${bldUserKeyPath}' yarn lerna version ${params.LERNA_VERSION_FLAGS} > lerna_version.txt
              """
              script {
                def json = sh(returnStdout: true, script: $/node generate_lerna_version_json.js && echo $(cat lerna_version.json)/$).trim();
                env.RELEASE_JSON = json;
                def lazyMap = new groovy.json.JsonSlurper().parseText(json);
                for (prop in lazyMap) {
                  updatedPackagesMap[prop.key] = prop.value;
                }
              }
            }
          }
        }
      }
    }

    stage('publish') {
      steps {
        dir("${env.WORKSPACE}") {
          container('ui-library-admin') {
            configFileProvider([configFile(fileId: 'NPM_SETTINGS_FOR_ART01', targetLocation: '.npmrc')]) {
              withVault([configuration: configuration, vaultSecrets: secrets]) {
                sh "echo 'Publishing packages to npmjs.org registry'"
                sh "echo \"registry=https://registry.npmjs.org/\" >> packages/schema-form/.npmrc"
                sh "echo \"//registry.npmjs.org/:_authToken=$NPM_TOKEN\" >> packages/schema-form/.npmrc"
                sh "echo \"registry=https://registry.npmjs.org/\" >> packages/astro/.npmrc"
                sh "echo \"//registry.npmjs.org/:_authToken=$NPM_TOKEN\" >> packages/astro/.npmrc"

                script {
                  if (updatedPackagesMap.containsKey("@pingux/schema-form")) {
                    echo 'Publishing @pingux/schema-form to npmjs.org'
                    sh 'cd packages/schema-form/ && npm publish'
                  }

                  if (updatedPackagesMap.containsKey("@pingux/astro")) {
                    echo 'Publishing @pingux/schema-form to npmjs.org'
                    sh 'cd packages/astro/ && npm publish'
                  }
                }

                echo "Publishing changed packages to Artifactory"
                sh "yarn lerna publish ${params.LERNA_PUBLISH_FLAGS}"
              }
            }
          }
        }
      }
    }

    stage('cdn build') {
      steps {
        dir("${env.WORKSPACE}") {
          container('ui-library-admin') {
            echo "Run Lerna CDN command"
            sh "yarn lerna run cdn"
          }
        }
        stash includes: 'packages/**/*', excludes: '**/node_modules/**', name: 'packages'
      }
    }

    stage('update demos') {
      steps {
        dir("${env.WORKSPACE}") {
          container('ui-library-admin') {
            withCredentials([sshUserPrivateKey(credentialsId: "uilibrary.ping-eng.com-ubuntu-user", keyFileVariable: 'keyfile')]) {
              script {
                def packageKeys = updatedPackagesMap.keySet() as List;
                if (packageKeys.size() > 0) {
                  // Update those demos using their Makefile
                  packageKeys.each() {
                    def packagePath = it.replaceAll("@pingux/", "");
                    echo "updated package ${it}: path ${packagePath}"
                    sh "cd packages/${packagePath} && make PRIVATE_SSH_KEY_PATH=${keyfile} LIB_VERSION=${updatedPackagesMap[it]} package-and-upload-for-hosting"
                  }
                }
              }
            }
          }
        }
      }
    }

    stage('cdn deploy test') {
      agent {
        kubernetes(agentDefinition(
          name: 'test-cdn-deploy',
          cloud: testCluster
        ))
      }
      environment {
        ENVIRONMENT = "test"
      }
      steps {
        container('cdn-deploy') {
          checkout scm
          unstash 'packages'
          script {
            def cdnKeys = globalCdnMap.keySet() as List;
            def packageKeys = updatedPackagesMap.keySet() as List;
            // Get list of updated packages with cdn deployments
            def cdnDeployments = cdnKeys.intersect(packageKeys);
            if (cdnDeployments.size() > 0) {
              // Update each package's cdn deployment
              cdnDeployments.each() {
                def releaseVersion = updatedPackagesMap[it];
                env.PING_SERVICE_NAME = it.replaceAll("@pingux/", "");
                env.CDN_SOURCE =  "${globalCdnMap[it]}/${releaseVersion}"
                env.UNIQUE_CDN_FOLDER = "${releaseVersion}"
                echo "test upload CDN_SOURCE: ${CDN_SOURCE} UNIQUE_CDN_FOLDER: ${UNIQUE_CDN_FOLDER}"
                sh "echo ${env.GIT_COMMIT} >> ${CDN_SOURCE}/VERSION.txt"
                sh 'upload_ui'
              }
            }
          }
        }
      }
    }

    stage('cdn deploy ort') {
      agent {
        kubernetes(agentDefinition(
          name: 'ort-cdn-deploy',
          cloud: centralCluster
        ))
      }
      environment {
        ENVIRONMENT = "staging"
      }
      steps {
        container('cdn-deploy') {
          checkout scm
          unstash 'packages'
          script {
            def cdnKeys = globalCdnMap.keySet() as List;
            def packageKeys = updatedPackagesMap.keySet() as List;
            // Get list of updated packages with cdn deployments
            def cdnDeployments = cdnKeys.intersect(packageKeys);
            if (cdnDeployments.size() > 0) {
              // Update each package's cdn deployment
              cdnDeployments.each() {
                def releaseVersion = updatedPackagesMap[it];
                env.PING_SERVICE_NAME = it.replaceAll("@pingux/", "");
                env.CDN_SOURCE =  "${globalCdnMap[it]}/${releaseVersion}"
                env.UNIQUE_CDN_FOLDER = "${releaseVersion}"
                echo "ort upload CDN_SOURCE: ${CDN_SOURCE} UNIQUE_CDN_FOLDER: ${UNIQUE_CDN_FOLDER}"
                sh 'upload_ui'
              }
            }
          }
        }
      }
    }

    stage('cdn deploy prod') {
      agent {
        kubernetes(agentDefinition(
          name: 'prod-cdn-deploy',
          cloud: centralCluster
        ))
      }
      environment {
        ENVIRONMENT = "production"
      }
      steps {
        container('cdn-deploy') {
          checkout scm
          unstash 'packages'
          script {
            def cdnKeys = globalCdnMap.keySet() as List;
            def packageKeys = updatedPackagesMap.keySet() as List;
            // Get list of updated packages with cdn deployments
            def cdnDeployments = cdnKeys.intersect(packageKeys);
            if (cdnDeployments.size() > 0) {
              // Update each package's cdn deployment
              cdnDeployments.each() {
                def releaseVersion = updatedPackagesMap[it];
                env.PING_SERVICE_NAME = it.replaceAll("@pingux/", "");
                env.CDN_SOURCE =  "${globalCdnMap[it]}/${releaseVersion}"
                env.UNIQUE_CDN_FOLDER = "${releaseVersion}"
                echo "prod upload CDN_SOURCE: ${CDN_SOURCE} UNIQUE_CDN_FOLDER: ${UNIQUE_CDN_FOLDER}"
                sh 'upload_ui'
              }
            }
          }
        }
      }
    }
  }

  post {
    success {
      script {
        // Send Slack notifications
        def message = """
            :tada: Release success!
            
            ```
            ${env.RELEASE_JSON}
            ```

            Build details: <${env.BUILD_URL}/console|See in web console>
          """.stripIndent()

        slackSend channel: '#ux-deployments', message: "${message}", color: "#4aba78"

        def packageKeys = updatedPackagesMap.keySet() as List;
        if (packageKeys.size() > 0) {
          // Send a message to each updated package's channel
          packageKeys.each() {
            if (it == "@pingux/astro") {
              def astroMessage = generateSlackMessage(
                "Astro",
                "astro",
                "${updatedPackagesMap[it]}"
              );
              slackSend channel: '#ui-announcements', message: "${astroMessage}", color: "#4aba78"
            } else if (it == "@pingux/branding-themes") {
              def brandingThemesMessage = generateSlackMessage(
                "Branding Themes",
                "branding-themes",
                "${updatedPackagesMap[it]}"
              );
              slackSend channel: '#ui-announcements', message: "${brandingThemesMessage}", color: "#4aba78"
            } else if (it == "@pingux/end-user") {
              def endUserMessage = generateSlackMessage(
                "End User",
                "end-user",
                "${updatedPackagesMap[it]}"
              );
              slackSend channel: '#ui-announcements', message: "${endUserMessage}", color: "#4aba78"
            } else if (it == "@pingux/flow-diagram") {
              def flowDiagramMessage = generateSlackMessage(
                "Flow Diagram",
                "flow-diagram",
                "${updatedPackagesMap[it]}"
              );
              slackSend channel: '#ui-announcements', message: "${flowDiagramMessage}", color: "#4aba78"
            } else if (it == "@pingux/schema-form") {
              def schemaFormMessage = generateSlackMessage(
                "Schema Form",
                "schema-form",
                "${updatedPackagesMap[it]}"
              );
              slackSend channel: '#ui-announcements', message: "${schemaFormMessage}", color: "#4aba78"
            } else if (it == "ui-library") {
              def uiLibraryMessage = generateSlackMessage(
                "UI Library",
                "ui-library",
                "${updatedPackagesMap[it]}"
              );
              slackSend channel: '#ui-announcements', message: "${uiLibraryMessage}", color: "#4aba78"
            }
          }
        }
      }
    }
    unsuccessful {
      script {
        def message = """
          :x: Release failure...
          Build details: <${env.BUILD_URL}/console|See in web console>
        """.stripIndent()
        slackSend channel: '#ux-deployments', message: "${message}", color: "#a31300"
      }
    }
    cleanup {
      cleanWs()
    }
  }
}
