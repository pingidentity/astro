@Library(['mpl-library', 'jenkins-ci-library']) _
// https://gitlab.corp.pingidentity.com/devtools/icecream/jenkins-mpl-library
// https://gitlab.corp.pingidentity.com/devtools/icecream/jenkins-ci-library

def ortCdnDeploy = libraryResource 'podTemplates/central-only/ort-cdn-deploy.yaml';
def prodCdnDeploy = libraryResource 'podTemplates/central-only/prod-cdn-deploy.yaml';
def uiPipelineShared = libraryResource 'podTemplates/ui-pipeline-shared.yaml';
def centralCluster = 'central-us-east-2-k8s';

// Schema Form NPM publish stuff
def configuration = [
  vaultUrl: 'https://prod-vault-us-east-2.awscloud.pingidentity.net',
  vaultCredentialId: 'jenkins-icecream-pipeline',
  engineVersion: 2
]
def secrets = [
  [
    path: 'secret/central/jenkins-icecream/ux/pingux',
    engineVersion: 2,
    secretValues: [
      [envVar: 'NPM_TOKEN', vaultKey: 'NPM_TOKEN']
    ]
  ]
]

// Logic utils
def globalCdnMap = [
  'ui-library': 'packages/ui-library/cdn',
  '@pingux/end-user': 'packages/end-user/cdn',
  '@pingux/icons': 'packages/icons/cdn',
  '@pingux/branding-themes': 'packages/branding-themes/build/cdn'
];
def updatedPackagesMap = [:];

pipeline {
  agent {
    kubernetes {
      cloud centralCluster
      yaml uiPipelineShared
    }
  }
  parameters {
    string(name: 'LERNA_VERSION_FLAGS', defaultValue: '--conventional-commits --yes', description: 'Flags applied to the `lerna version` command.')
    string(name: 'LERNA_PUBLISH_FLAGS', defaultValue: 'from-git --yes', description: 'Flags applied to the `lerna publish` command.')
  }
  environment {
    PING_TEAM_NAME = "ux"
  }
  stages {
    stage('install and link') {
      steps {
        dir("${env.WORKSPACE}") {
          container('node-builder') {
            echo "Installing and linking packages"
            sh "yarn --frozen-lockfile --ignore-engines"
            sh "yarn lerna run build"
          }
        }
        stash includes: 'packages/**/*', excludes: '**/node_modules/**', name: 'packages'
      }
    }

    stage('lint') {
      steps {
        dir("${env.WORKSPACE}") {
          container('node-builder') {
            echo "Linting packages"
            sh 'yarn lerna run lint'
          }
        }
      }
    }

    stage('test') {
      steps {
        dir("${env.WORKSPACE}") {
          container('node-builder') {
            echo "Running tests for packages"
            sh 'yarn lerna run test'
          }
        }
      }
    }

    stage('version') {
      steps {
        dir("${env.WORKSPACE}") {
          container('node-builder') {
            echo "Versioning packages"
            withCredentials([
              sshUserPrivateKey(credentialsId: "jenkins-build-user", keyFileVariable: 'bldUserKeyPath')
            ]) {
              // Lerna changed for debugging purposes
              sh """
                yarn lerna changed
                git config --global user.email 'devtools+jenkins@pingidentity.com'
                git config --global user.name 'devtools-jenkins'
                GIT_SSH_COMMAND='ssh -o StrictHostKeyChecking=no -i ${bldUserKeyPath}' yarn lerna version ${LERNA_VERSION_FLAGS} > lerna_version.txt
              """
              script {
                def json = sh(returnStdout: true, script: $/node generate_lerna_version_json.js && echo $(cat lerna_version.json)/$).trim();
                env.RELEASE_JSON = json;
                def lazyMap = new groovy.json.JsonSlurper().parseText(json);
                for (prop in lazyMap) {
                  updatedPackagesMap[prop.key] = prop.value;
                }
              }
            }
          }
        }
      }
    }

    stage('publish') {
      steps {
        dir("${env.WORKSPACE}") {
          container('node-builder') {
            configFileProvider([configFile(fileId: 'NPM_SETTINGS_FOR_ART01', targetLocation: '.npmrc')]) {
              withVault([configuration: configuration, vaultSecrets: secrets]) {
                sh "echo 'Publishing Schema Form to NPM registry'"
                sh "echo \"registry=https://registry.npmjs.org/\" >> packages/schema-form/.npmrc"
                sh "echo \"//registry.npmjs.org/:_authToken=$NPM_TOKEN\" >> packages/schema-form/.npmrc"
                echo "Publishing changed packages"
                sh 'yarn lerna publish ${LERNA_PUBLISH_FLAGS}'
              }
            }
          }
        }
      }
    }

    stage('cdn build') {
      steps {
        dir("${env.WORKSPACE}") {
          container('node-builder') {
            echo "Run Lerna CDN command"
            sh "yarn lerna run cdn"
          }
        }
        stash includes: 'packages/**/*', excludes: '**/node_modules/**', name: 'packages'
      }
    }

    stage('update demos') {
      steps {
        dir("${env.WORKSPACE}") {
          container('node-builder') {
            withCredentials([sshUserPrivateKey(credentialsId: "uilibrary.ping-eng.com-ubuntu-user", keyFileVariable: 'keyfile')]) {
              script {
                def packageKeys = updatedPackagesMap.keySet() as List;
                if (packageKeys.size() > 0) {
                  // Update those demos using their Makefile
                  packageKeys.each() {
                    def packagePath = it.replaceAll("@pingux/", "");
                    echo "updated package ${it}: path ${packagePath}"
                    sh "cd packages/${packagePath} && make PRIVATE_SSH_KEY_PATH=${keyfile} LIB_VERSION=${updatedPackagesMap[it]} package-and-upload-for-hosting"
                  }
                }
              }
            }
          }
        }
      }
    }

    stage('cdn deploy test') {
      agent { label 'test-cdn-deploy' }
      environment {
        ENVIRONMENT = "test"
      }
      steps {
        container('cdn-deploy') {
          checkout scm
          unstash 'packages'
          script {
            def cdnKeys = globalCdnMap.keySet() as List;
            def packageKeys = updatedPackagesMap.keySet() as List;
            // Get list of updated packages with cdn deployments
            def cdnDeployments = cdnKeys.intersect(packageKeys);
            if (cdnDeployments.size() > 0) {
              // Update each package's cdn deployment
              cdnDeployments.each() {
                def releaseVersion = updatedPackagesMap[it];
                env.PING_SERVICE_NAME = it.replaceAll("@pingux/", "");
                env.CDN_SOURCE =  "${globalCdnMap[it]}/${releaseVersion}"
                env.UNIQUE_CDN_FOLDER = "${releaseVersion}"
                echo "test upload CDN_SOURCE: ${CDN_SOURCE} UNIQUE_CDN_FOLDER: ${UNIQUE_CDN_FOLDER}"
                sh "echo ${env.GIT_COMMIT} >> ${CDN_SOURCE}/VERSION.txt"
                sh 'upload_ui'
              }
            }
          }
        }
      }
    }

    stage('cdn deploy ort') {
      agent {
        kubernetes {
          cloud centralCluster
          yaml ortCdnDeploy
        }
      }
      environment {
        ENVIRONMENT = "staging"
      }
      steps {
        container('cdn-deploy') {
          checkout scm
          unstash 'packages'
          script {
            def cdnKeys = globalCdnMap.keySet() as List;
            def packageKeys = updatedPackagesMap.keySet() as List;
            // Get list of updated packages with cdn deployments
            def cdnDeployments = cdnKeys.intersect(packageKeys);
            if (cdnDeployments.size() > 0) {
              // Update each package's cdn deployment
              cdnDeployments.each() {
                def releaseVersion = updatedPackagesMap[it];
                env.PING_SERVICE_NAME = it.replaceAll("@pingux/", "");
                env.CDN_SOURCE =  "${globalCdnMap[it]}/${releaseVersion}"
                env.UNIQUE_CDN_FOLDER = "${releaseVersion}"
                echo "ort upload CDN_SOURCE: ${CDN_SOURCE} UNIQUE_CDN_FOLDER: ${UNIQUE_CDN_FOLDER}"
                sh 'upload_ui'
              }
            }
          }
        }
      }
    }

    stage('cdn deploy prod') {
      agent {
        kubernetes {
          cloud centralCluster
          yaml prodCdnDeploy
        }
      }
      environment {
        ENVIRONMENT = "production"
      }
      steps {
        container('cdn-deploy') {
          checkout scm
          unstash 'packages'
          script {
            def cdnKeys = globalCdnMap.keySet() as List;
            def packageKeys = updatedPackagesMap.keySet() as List;
            // Get list of updated packages with cdn deployments
            def cdnDeployments = cdnKeys.intersect(packageKeys);
            if (cdnDeployments.size() > 0) {
              // Update each package's cdn deployment
              cdnDeployments.each() {
                def releaseVersion = updatedPackagesMap[it];
                env.PING_SERVICE_NAME = it.replaceAll("@pingux/", "");
                env.CDN_SOURCE =  "${globalCdnMap[it]}/${releaseVersion}"
                env.UNIQUE_CDN_FOLDER = "${releaseVersion}"
                echo "prod upload CDN_SOURCE: ${CDN_SOURCE} UNIQUE_CDN_FOLDER: ${UNIQUE_CDN_FOLDER}"
                sh 'upload_ui'
              }
            }
          }
        }
      }
    }
  }

  post {
    success {
      script {
        def message = """
          :tada: Release success!
          Release details: `${env.RELEASE_JSON}`
          Build details: <${env.BUILD_URL}/console|See in web console>
        """.stripIndent()
        slackSend channel: '#ux-deployments', message: "${message}", color: "#4aba78"
      }
    }
    unsuccessful {
      script {
        def message = """
          :x: Release failure...
          Build details: <${env.BUILD_URL}/console|See in web console>
        """.stripIndent()
        slackSend channel: '#ux-deployments', message: "${message}", color: "#a31300"
      }
    }
    cleanup {
      cleanWs()
    }
  }
}
