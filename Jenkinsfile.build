#!/usr/bin/env groovy

@Library(['jenkins-ci-library']) _

import groovy.json.JsonOutput

def testCluster = 'test'

// Schema Form NPM publish stuff
def configuration = [
  vaultUrl: 'https://prod-vault-us-east-2.awscloud.pingidentity.net',
  vaultCredentialId: 'jenkins-icecream-pipeline',
  engineVersion: 2
]
def secrets = [
  [
    path: 'secret/central/jenkins-icecream/ux/pingux',
    engineVersion: 2,
    secretValues: [
      [envVar: 'NPM_TOKEN', vaultKey: 'NPM_TOKEN']
    ]
  ]
]

// Logic utils
def globalCdnMap = [
  'ui-library': 'packages/ui-library/cdn',
  '@pingux/end-user': 'packages/end-user/cdn',
  '@pingux/icons': 'packages/icons/cdn',
  '@pingux/branding-themes': 'packages/branding-themes/build/cdn'
];
def updatedPackagesMap = [:];

def generateSlackMessage(packageName, packagePathName, packageVersion) {
  return """
    :tada: ${packageName} ${packageVersion} has been released!
    
    <https://gitlab.corp.pingidentity.com/ux/pingux/-/blob/master/packages/${packagePathName}/CHANGELOG.md|See the CHANGELOG for more details>
  """.stripIndent()
}

pipeline {
  agent {
    kubernetes (
      agentDefinition(
        name: 'ui-library-agent',
        cloud: testCluster,
        yaml: """
        apiVersion: v1
        kind: Pod
        metadata:
          name: ui-library-agent
        spec:
          containers:
            - name: "ui-library-admin"
              command: # Jenkinsfile overwrites this, but k8s spec requires it
              - cat
              image: "docker.corp.pingidentity.com:5000/testing/ui-library-admin:1.2"
              imagePullPolicy: Always
              workingDir: "/home/jenkins/agent"
              tty: true"""
      )
    )
  }
  stages {
    stage("set version and release flags") {
      steps {
        script {
          echo "The current branch is: ${env.BRANCH_NAME} or ${env.CHANGE_TARGET}"
          switch(env.BRANCH_NAME) {
            case 'develop':
              env.LERNA_VERSION_FLAGS = '--yes --conventional-commits --conventional-prerelease --no-changelog --no-git-tag-version'
              env.LERNA_PUBLISH_FLAGS = 'from-package --yes --pre-dist-tag next --registry https://art01.corp.pingidentity.com/artifactory/api/npm/npm-virtual/'
              env.LERNA_COMMIT_MESSAGE = 'chore(release): publish alpha build'
              break
            case ~/^release-.*/:
              env.LERNA_VERSION_FLAGS = '--yes --conventional-commits --conventional-prerelease --no-changelog --no-git-tag-version --preid rc'
              env.LERNA_PUBLISH_FLAGS = 'from-package --yes --pre-dist-tag next --registry https://art01.corp.pingidentity.com/artifactory/api/npm/npm-virtual/'
              env.LERNA_COMMIT_MESSAGE = 'chore(release): publish rc build'
              break
            default:
              // this causes the build to fail if the pre-release stage is triggered without the vars
              break
          }
        }
      }
    }

    stage('build-test-lint') {
      steps {
        container('ui-library-admin') {
          sh """
            yarn --frozen-lockfile
            lerna run build
            lerna run lint
            lerna run coverage-ci
          """
        }
      }
    }

    // Run automatically for all commits on develop and master, plus auto-accept any changes
    stage('chromatic on commit to develop') {
      when {
        beforeAgent true
        expression {
          env.BRANCH_NAME == 'develop'
        }
      }
      steps {
        container('ui-library-admin') {
          configFileProvider([configFile(fileId: 'NPM_SETTINGS_FOR_ART01', targetLocation: '.npmrc')]) {
            withVault([configuration: configuration, vaultSecrets: secrets]) {
              sh """
                yarn --frozen-lockfile
                --auto-accept-changes --project-token=$CHROMATIC_TOKEN --build-script-name demo --scope astro
              """
            }
          }
        }
      }
    }

    stage('version and publish') {
      when {
        expression {
          env.BRANCH_NAME == "develop" || env.BRANCH_NAME == ~/^release-.*/
        }
      }
      steps {
        dir("${env.WORKSPACE}") {
          container('ui-library-admin') {
            echo "Versioning packages"
            withCredentials([
              sshUserPrivateKey(credentialsId: "jenkins-build-user", keyFileVariable: 'bldUserKeyPath')
            ]) {
              sh """
                git config --global user.email 'devtools+jenkins@pingidentity.com'
                git config --global user.name 'devtools-jenkins'
                git checkout ${env.BRANCH_NAME}
                GIT_SSH_COMMAND='ssh -o StrictHostKeyChecking=no -i ${bldUserKeyPath}' git pull
                lerna changed || true
                GIT_SSH_COMMAND='ssh -o StrictHostKeyChecking=no -i ${bldUserKeyPath}' lerna version ${env.LERNA_VERSION_FLAGS} > lerna_version.txt
                git status
                git add .
                git status
                GIT_SSH_COMMAND='ssh -o StrictHostKeyChecking=no -i ${bldUserKeyPath}' git commit -m "${env.LERNA_COMMIT_MESSAGE}" || true
                GIT_SSH_COMMAND='ssh -o StrictHostKeyChecking=no -i ${bldUserKeyPath}' git push || true
              """
              script {
                def json = sh(returnStdout: true, script: $/node generate_lerna_version_json.js && echo $(cat lerna_version.json)/$).trim();
                env.RELEASE_JSON = json;
                def lazyMap = new groovy.json.JsonSlurper().parseText(json);
                for (prop in lazyMap) {
                  updatedPackagesMap[prop.key] = prop.value;
                }
              }
            }

            echo "Publishing packages"
            configFileProvider([configFile(fileId: 'NPM_SETTINGS_FOR_ART01', targetLocation: '.npmrc')]) {
              withVault([configuration: configuration, vaultSecrets: secrets]) {
                sh "echo 'Publishing packages to npmjs.org registry'"
                sh "echo \"registry=https://registry.npmjs.org/\" >> packages/schema-form/.npmrc"
                sh "echo \"//registry.npmjs.org/:_authToken=$NPM_TOKEN\" >> packages/schema-form/.npmrc"
                sh "echo \"registry=https://registry.npmjs.org/\" >> packages/astro/.npmrc"
                sh "echo \"//registry.npmjs.org/:_authToken=$NPM_TOKEN\" >> packages/astro/.npmrc"

                script {
                  if (updatedPackagesMap.containsKey("@pingux/schema-form")) {
                    echo 'Publishing @pingux/schema-form@next to npmjs.org'
                    sh 'cd packages/schema-form/ && npm publish --tag next'
                  }

                  if (updatedPackagesMap.containsKey("@pingux/astro")) {
                    echo 'Publishing @pingux/astro@next dist-tag to npmjs.org'
                    sh 'cd packages/astro/ && npm publish --tag next'
                  }
                }

                echo "Publishing changed packages to Artifactory"
                sh "yarn lerna publish ${env.LERNA_PUBLISH_FLAGS}"
              }
            }
          }
        }
      }
    }

    stage('cdn build') {
      when {
        beforeAgent true
        expression {  
          env.BRANCH_NAME == 'develop'
        }
      }
      steps {
        dir("${env.WORKSPACE}") {
          container('ui-library-admin') {
            echo "Run Lerna CDN command"
            sh "yarn lerna run cdn"
          }
        }
        stash includes: 'packages/**/*', excludes: '**/node_modules/**', name: 'packages'
      }
    }

    stage('cdn deploy test') {
      when {
        beforeAgent true
        expression {  
          env.BRANCH_NAME == 'develop'
        }
      }
      agent {
        kubernetes(agentDefinition(
          name: 'test-cdn-deploy',
          cloud: testCluster
        ))
      }
      environment {
        ENVIRONMENT = "test"
      }
      steps {
        container('cdn-deploy') {
          checkout scm
          unstash 'packages'
          script {
            def cdnKeys = globalCdnMap.keySet() as List;
            def packageKeys = updatedPackagesMap.keySet() as List;
            // Get list of updated packages with cdn deployments
            def cdnDeployments = cdnKeys.intersect(packageKeys);
            if (cdnDeployments.size() > 0) {
              // Update each package's cdn deployment
              cdnDeployments.each() {
                def releaseVersion = updatedPackagesMap[it];
                env.PING_SERVICE_NAME = it.replaceAll("@pingux/", "");
                env.CDN_SOURCE =  "${globalCdnMap[it]}/${releaseVersion}"
                env.UNIQUE_CDN_FOLDER = "${releaseVersion}"
                echo "test upload CDN_SOURCE: ${CDN_SOURCE} UNIQUE_CDN_FOLDER: ${UNIQUE_CDN_FOLDER}"
                sh "echo ${env.GIT_COMMIT} >> ${CDN_SOURCE}/VERSION.txt"
                sh 'upload_ui'
              }
            }
          }
        }
      }
    }
  }

  post {
    success {
      script {
        // Send Slack notifications
        def message = """
            :tada: Release success!
            
            ```
            ${env.RELEASE_JSON}
            ```

            Build details: <${env.BUILD_URL}/console|See in web console>
          """.stripIndent()

        if (env.BRANCH_NAME == "develop") {
          slackSend channel: '#ux-deployments', message: "${message}", color: "#4aba78"
        }
      }
    }
    unsuccessful {
      script {
        def message = """
          :x: Release failure...
          Build details: <${env.BUILD_URL}/console|See in web console>
        """.stripIndent()

        if (env.BRANCH_NAME == "develop") {
          slackSend channel: '#ux-deployments', message: "${message}", color: "#a31300"
        }
      }
    }
    cleanup {
      cleanWs()
    }
  }
}
